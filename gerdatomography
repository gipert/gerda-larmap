//usr/bin/env root -l ${0}\(${1}\); exit $?
/* gerda_tomography.C
 *
 * Author: Luigi Pertoldi - pertoldi@pd.infn.it
 * Created: Sun 24 Mar 2019
 */

const std::string OpenFileDialog();
void dynamic_exec();

float max_prob = 0;

// array closeup
bool array_closeup = false;
float xmin = -15;
float xmax = 15;
float ymin = -17;
float ymax = 17;
float zmin = -35;
float zmax = 15;

void gerdatomography(int rebin = 1) {

    if (gROOT->GetVersionInt() < 60900) {
        std::cerr << "ERROR: this program works properly with ROOT >= 6.09\n";
        gSystem->Exit(1);
    }

    // ask for input file
    std::string filename = OpenFileDialog();
    if (filename.empty()) { gSystem->Exit(0); }

    TFile* tfile = new TFile(filename.c_str(), "read");
    auto LAr_prob_map = dynamic_cast<TH3D*>(tfile->Get("LAr_prob_map"));
    if (!LAr_prob_map) {
        std::cout << "ERROR: LAr_prob_map object not found!\n"
                  << "File content:";
        tfile->ls();
        while (!LAr_prob_map) {
            std::string name;
            std::cout << "select another TH3D object: ";
            std::cin >> name;
            LAr_prob_map = dynamic_cast<TH3D*>(tfile->Get(name.c_str()));
        }
    }

    std::cout << "INFO: preparing histogram...\n";
    // this is needed for a meaningful rebin...
    for (int i = 0; i < LAr_prob_map->GetNcells(); ++i) {
        auto _p = LAr_prob_map->GetBinContent(i);
        if (_p < 0) LAr_prob_map->SetBinContent(i, 0);
        if (_p > max_prob) max_prob = _p;
    }

    // eventually rebin
    LAr_prob_map->Rebin3D(rebin, rebin, rebin);
    LAr_prob_map->Scale(1./(rebin*rebin*rebin));

    std::cout << "INFO: displaying, this could take a while...\n";
    auto canvas = new TCanvas(
        "gerda_tomography", "GERDA Tomography",
        1800, 1000
    );
    canvas->ToggleEventStatus();

    // this should enable the "invert" drawing mode
    // if a shape is re-drawn then it should disappear
    canvas->FeedbackMode(true);

    auto main_pad = new TPad(
        "main_pad", "Main Pad",
        0.0, 0.0, 0.33, 1.0
    );
    main_pad->SetMargin(0, 0, 0, 0);
    auto xz_pad = new TPad(
        "xz_pad", "XZ Projection Pad",
        0.33, 0.0, 0.66, 1.0
    );
    xz_pad->SetLogz();
    xz_pad->SetGrid();
    xz_pad->SetTicks(1,1);
    xz_pad->SetTopMargin(0.1);
    xz_pad->SetRightMargin(0.12);
    auto xy_pad = new TPad(
        "xy_pad", "XY Projection Pad",
        0.66, 0.33, 1.0, 1.0
    );
    xy_pad->SetLogz();
    xy_pad->SetGrid();
    xy_pad->SetTicks(1,1);
    xy_pad->SetTopMargin(0.14);
    xy_pad->SetRightMargin(0.12);

    main_pad->Draw();
    xz_pad->Draw();
    xy_pad->Draw();

    main_pad->cd();
    LAr_prob_map->SetTitle("LAr photon detection probability map;x [cm];y [cm];z [cm]");
    LAr_prob_map->SetStats(false);
    LAr_prob_map->SetMinimum(0);
    LAr_prob_map->SetMaximum(max_prob);
    LAr_prob_map->Draw("a fb bb lego");

    // pre-draw something
    auto hp_xz = dynamic_cast<TH2*>(LAr_prob_map->Project3D("zx"));
    hp_xz->Reset();
    hp_xz->SetTickLength(0.01, "X");
    hp_xz->SetTickLength(0.02, "Y");
    hp_xz->SetTitleOffset(1.30, "Y");
    hp_xz->SetZTitle("");
    hp_xz->SetStats(false);
    hp_xz->SetMinimum(0);
    hp_xz->SetMaximum(max_prob);
    hp_xz->SetTitle("XZ slice");
    xz_pad->cd();
    hp_xz->Draw("colz");

    auto hp_xy = dynamic_cast<TH2*>(LAr_prob_map->Project3D("xy"));
    hp_xy->Reset();
    hp_xy->SetTickLength(0.01, "X");
    hp_xy->SetTickLength(0.02, "Y");
    hp_xy->SetTitleOffset(1.30, "Y");
    hp_xy->SetZTitle("");
    hp_xy->SetStats(false);
    hp_xy->SetMinimum(0);
    hp_xy->SetMaximum(max_prob);
    hp_xy->SetTitle("XY slice");
    xy_pad->cd();
    hp_xy->Draw("colz");

    // attach dynamic behaviour
    main_pad->AddExec("dynamic", "dynamic_exec()");

    return;
}

void dynamic_exec() {

    auto nbins = 1;

    // check if mouse pointer is in the correct region
    auto *select = gPad->GetSelected();
    if (!select or !select->InheritsFrom(TH3::Class())) return;
    auto h = dynamic_cast<TH3*>(select);

    // mouse pointer position
    int px = gPad->GetEventX();
    int py = gPad->GetEventY();

    auto view = gPad->GetView();
    if (!view) return;

    double u_xz[3], xx_xz[3];
    double u_xy[3], xx_xy[3];

    static TPoint rect1_xz[5]; // store vertices of the polyline (rectangle), initialsed 0 by default
    static TPoint rect1_xy[5];

    double uxmin = gPad->GetUxmin();
    double uxmax = gPad->GetUxmax();
    double uymin = gPad->GetUymin();
    double uymax = gPad->GetUymax();

    int pxmin = gPad->XtoAbsPixel(uxmin);
    int pxmax = gPad->XtoAbsPixel(uxmax);
    if (pxmin == pxmax) return;
    int pymin = gPad->YtoAbsPixel(uymin);
    int pymax = gPad->YtoAbsPixel(uymax);
    if (pymin == pymax) return;
    Double_t cx = (pxmax-pxmin)/(uxmax-uxmin);
    Double_t cy = (pymax-pymin)/(uymax-uymin);

    auto main_pad = gPad;
    auto canvas = dynamic_cast<TCanvas*>(gPad->GetCanvas());

    auto xaxis = h->GetXaxis();
    auto yaxis = h->GetYaxis();
    auto zaxis = h->GetZaxis();

    /////////////////
    // xz polyline //
    /////////////////

    auto c_xz = dynamic_cast<TPad*>(canvas->GetListOfPrimitives()->FindObject("xz_pad"));
    if (!c_xz) return;

    // erase old polyline
    // if (rect1_xz[0].GetX()) gVirtualX->DrawPolyLine(5, rect1_xz);

    // compute polyline
    int first_xz = yaxis->GetFirst();
    int last_xz  = yaxis->GetLast();
    int biny_xz = first_xz + int((last_xz-first_xz)*(px-pxmin)/(pxmax-pxmin));
    int biny2_xz = TMath::Min(biny_xz+nbins-1, yaxis->GetNbins());
    yaxis->SetRange(biny_xz, biny2_xz);
    xx_xz[0] = xaxis->GetXmin();
    xx_xz[2] = zaxis->GetXmax();
    xx_xz[1] = yaxis->GetBinCenter(biny_xz);
    view->WCtoNDC(xx_xz, u_xz);
    rect1_xz[0].SetX(pxmin + int((u_xz[0]-uxmin)*cx));
    rect1_xz[0].SetY(pymin + int((u_xz[1]-uymin)*cy));
    rect1_xz[4].SetX(rect1_xz[0].GetX());
    rect1_xz[4].SetY(rect1_xz[0].GetY());
    xx_xz[0] = xaxis->GetXmax();
    view->WCtoNDC(xx_xz, u_xz);
    rect1_xz[1].SetX(pxmin + int((u_xz[0]-uxmin)*cx));
    rect1_xz[1].SetY(pymin + int((u_xz[1]-uymin)*cy));
    xx_xz[2] = zaxis->GetXmin();
    view->WCtoNDC(xx_xz, u_xz);
    rect1_xz[2].SetX(pxmin + int((u_xz[0]-uxmin)*cx));
    rect1_xz[2].SetY(pymin + int((u_xz[1]-uymin)*cy));
    xx_xz[0] = xaxis->GetXmin();
    view->WCtoNDC(xx_xz, u_xz);
    rect1_xz[3].SetX(pxmin + int((u_xz[0]-uxmin)*cx));
    rect1_xz[3].SetY(pymin + int((u_xz[1]-uymin)*cy));

    ///////////////////
    // xy projection //
    ///////////////////

    auto c_xy = dynamic_cast<TPad*>(canvas->GetListOfPrimitives()->FindObject("xy_pad"));
    if (!c_xy) return;

    // erase old polyline
    // if (rect1_xy[0].GetX()) gVirtualX->DrawPolyLine(5, rect1_xy);

    // compute polyline
    int first_xy = zaxis->GetFirst();
    int last_xy  = zaxis->GetLast();
    int binz_xy  = first_xy + int((last_xy-first_xy)*(py-pymin)/(pymax-pymin));
    int binz2_xy = TMath::Min(binz_xy+nbins-1, zaxis->GetNbins());
    zaxis->SetRange(binz_xy, binz2_xy);
    xx_xy[0] = xaxis->GetXmin();
    xx_xy[1] = yaxis->GetXmax();
    xx_xy[2] = zaxis->GetBinCenter(binz_xy);
    view->WCtoNDC(xx_xy, u_xy);
    rect1_xy[0].SetX(pxmin + int((u_xy[0]-uxmin)*cx));
    rect1_xy[0].SetY(pymin + int((u_xy[1]-uymin)*cy));
    rect1_xy[4].SetX(rect1_xy[0].GetX());
    rect1_xy[4].SetY(rect1_xy[0].GetY());
    xx_xy[0] = xaxis->GetXmax();
    view->WCtoNDC(xx_xy, u_xy);
    rect1_xy[1].SetX(pxmin + int((u_xy[0]-uxmin)*cx));
    rect1_xy[1].SetY(pymin + int((u_xy[1]-uymin)*cy));
    xx_xy[1] = yaxis->GetXmin();
    view->WCtoNDC(xx_xy, u_xy);
    rect1_xy[2].SetX(pxmin + int((u_xy[0]-uxmin)*cx));
    rect1_xy[2].SetY(pymin + int((u_xy[1]-uymin)*cy));
    xx_xy[0] = xaxis->GetXmin();
    view->WCtoNDC(xx_xy, u_xy);
    rect1_xy[3].SetX(pxmin + int((u_xy[0]-uxmin)*cx));
    rect1_xy[3].SetY(pymin + int((u_xy[1]-uymin)*cy));

    c_xz->Clear();
    c_xz->cd();

    // restore axis props
    zaxis->UnZoom();
    yaxis->SetRange(biny_xz, biny2_xz);

    // delete old projection
    auto hp_xz_old = dynamic_cast<TH2*>(canvas->GetListOfPrimitives()->FindObject("LAr_prob_map_zx"));
    if (hp_xz_old) delete hp_xz_old;

    // do the new projection
    auto hp_xz = dynamic_cast<TH2*>(h->Project3D("zx"));

    yaxis->SetRange(first_xz, last_xz);

    if (hp_xz) {
        hp_xz->SetTitle(
            TString::Format("XZ slice - bin %d, y #in [%.1f, %.f]",
                biny_xz, yaxis->GetBinLowEdge(biny_xz), yaxis->GetBinUpEdge(biny_xz))
        );
        hp_xz->SetTickLength(0.01, "X");
        hp_xz->SetTickLength(0.02, "Y");
        hp_xz->SetTitleOffset(1.30, "Y");
        hp_xz->SetZTitle("");
        hp_xz->SetStats(false);
        hp_xz->SetMinimum(0);
        hp_xz->SetMaximum(max_prob);
        hp_xz->Draw("colz");
    }

    c_xy->Clear();
    c_xy->cd();

    yaxis->UnZoom();
    zaxis->SetRange(binz_xy, binz2_xy);

    // delete old projection
    auto hp_xy_old = dynamic_cast<TH2*>(canvas->GetListOfPrimitives()->FindObject("LAr_prob_map_xy"));
    if (hp_xy_old) delete hp_xy_old;

    // do the new projection
    auto hp_xy = dynamic_cast<TH2*>(h->Project3D("xy"));

    zaxis->SetRange(first_xy, last_xy);

    if (hp_xy) {
        hp_xy->SetTitle(
            TString::Format("XY slice - bin %d, z #in [%.1f, %.f]",
                binz_xy, zaxis->GetBinLowEdge(binz_xy), zaxis->GetBinUpEdge(binz_xy))
        );
        hp_xy->SetTickLength(0.01, "X");
        hp_xy->SetTickLength(0.02, "Y");
        hp_xy->SetTitleOffset(1.30, "Y");
        hp_xy->SetZTitle("");
        hp_xy->SetStats(false);
        hp_xy->SetMinimum(0);
        hp_xy->SetMaximum(max_prob);
        hp_xy->Draw("colz");
    }

    if (array_closeup) {
        hp_xz->GetXaxis()->SetRangeUser(xmin, xmax);
        hp_xz->GetYaxis()->SetRangeUser(zmin, zmax);
        hp_xy->GetXaxis()->SetRangeUser(xmin, xmax);
        hp_xy->GetYaxis()->SetRangeUser(ymin, ymax);
    }
    c_xy->Update();
    c_xz->Update();

    main_pad->cd();

    // draw the polylines
    // gVirtualX->DrawPolyLine(5, rect1_xy);
    // gVirtualX->DrawPolyLine(5, rect1_xz);
}

const std::string OpenFileDialog() {
   // Prompt for file to be opened. Depending on navigation in
   // dialog the current working directory can be changed.
   // The returned file name is always with respect to the
   // current directory.

   const char *gOpenAsTypes[] = {
      "ROOT files",   "*.root",
      "All files",    "*",
       0,              0
   };

   static TGFileInfo fi;
   fi.fFileTypes = gOpenAsTypes;
   new TGFileDialog(gClient->GetRoot(), gClient->GetRoot(), kFDOpen, &fi);

   if (fi.fFilename) return std::string(fi.fFilename);
   else return "";
}

// vim: filetype=cpp
